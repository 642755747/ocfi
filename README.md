## Structure of the projects

We introduce OCFI, a modified LLVM/Clang compiler that offers the capability to obfuscate the `.eh_frame` section of compiled binaries. This obfuscation process aims to make it more challenging for disassemblers to identify function entries.

By leveraging OCFI, C/C++ projects can be compiled with the obfuscation feature enabled. This means that the resulting binaries will have their `.eh_frame` sections modified, enhancing their resistance to reverse engineering attempts and making the analysis of function boundaries more difficult for disassemblers. The application of OCFI as a compiler tool provides an additional layer of security for C/C++ projects, safeguarding sensitive code and intellectual property from potential attackers or unauthorized access.

Below is the structure of the projects, including the source code of OCFI, USmith, and other materials necessary to reproduce the results:

```bash
.
|-- ocfi             # source code of llvm-12.0.0 with ocfi
|-- usmith			        # source code of usmith
|-- script                  # scripts that we use to compare and collect the result
|-- hook_cxa_throw			# source code of hook cxa_throw and cxa_rethrow 
|-- cpu2017_config	        # scripts and configure files for build and run cpu2017
`-- fuzz_input	            # input generated by fuzzing for triggering exception
```

## Getting Started

### Set up enevironment

The prototype of OCFI is tested on Ubuntu 20.04 and the minimal disk space is about 150 GB. 

``` bash
apt-get update && \
    apt-get install -y \
    build-essential \
    cmake \
    git \
    wget \
    zlib1g-dev \
    python3 \
    python \
    python3-pip \
    m4 \
    binutils-multiarch-dev \
    libjpeg-dev \
    bc
pip3 install protobuf \
    capstone \
    pyelftools \
    sqlalchemy
```

### Build OCFI

There are two methods available for building the toolchains of OCFI in x86/x64: Ubuntu 20.04 and Docker. Please note that building the toolchains can be time-consuming. If you want to quickly test the validity of the toolchains, we recommend pulling the pre-built Docker image directly.

#### Method 1: Ubuntu 20.04 (~1.5h)

##### Step 1. Download the source code of OCFI

``` bash
git clone https://github.com/NJUSeclab/OCFI.git
export PROJECT_DIR=$PWD
cd ocfi
```

##### Step 2. Build the OCFI(~1h)

```bash
mkdir -p $PROJECT_DIR/llvm_ocfi
cd $PROJECT_DIR/llvm_ocfi
cmake $PROJECT_DIR/ocfi/llvm -DCMAKE_INSTALL_PREFIX=$PWD -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" 
make -j
make install
```
##### Step 3. Setup the environment variable(~1min)
```bash
export CC="$PROJECT_DIR/llvm_ocfi/bin/clang"
export CXX="$PROJECT_DIR/llvm_ocfi/bin/clang++"
export CFLAGS="-g -fuse-ld=gold"
export CXXFLAGS="-g -fuse-ld=gold"
```

##### Step 4. Build Usmith(~5mins)
```bash
mkdir -p $PROJECT_DIR/usmith_build
cd $PROJECT_DIR/usmith_build
cmake $PROJECT_DIR/usmith -DCMAKE_INSTALL_PREFIX=$PWD
make -j
make install
```

#### Method 2: Pull from dockerhub(~5mins)

```bash
docker pull z472421519/ocfi
docker run -it --privileged --name ocfi z472421519/ocfi /bin/bash
$CXX --version
```

The supposed result is shown as follows:
```
clang version 12.0.0
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /test/llvm_ocfi/bin
```

### Quick Test 

To evaluate the effectiveness and availability of OCFI, we have chosen the real-world software "[qpdf](https://github.com/qpdf/qpdf)" as our example. By using this well-established software, we aim to assess how OCFI performs in a practical, real-world scenario.

#### Test OCFI

##### Build qpdf(~3mins)

We first use the OCFI to build qpdf and check the obfuscated `.eh_frame`

```bash
cd $PROJECT_DIR
wget https://github.com/qpdf/qpdf/releases/download/v11.0.0/qpdf-11.0.0.tar.gz
tar -xvf qpdf-11.0.0.tar.gz
cd qpdf-11.0.0
mkdir -p build && cd build
cmake .. -DCMAKE_INSTALL_PREFIX=$PWD
make -j && make install
```

##### Check the effectiveness

We extract the obfuscated `.eh_frame` information and compare it with the symbol information to show the effect of obfuscation.

```bash
# extract the eh_frame from obfuscated binary for comparing
bash $PROJECT_DIR/script/run_extract_linux_eh.sh -d $PROJECT_DIR/qpdf-11.0.0/build/bin
# compare the function entry info from eh_frame and symbol
python3 $PROJECT_DIR/script/compare/checkObfuscateFuncsBySym.py -b $PROJECT_DIR/qpdf-11.0.0/build/bin/fix-qdf -c $PROJECT_DIR/qpdf-11.0.0/build/bin/fix-qdf.eh
```

The supposed result is shown as follows:

```plain text
[Result]:The total Functions in ground truth is 2041
[Result]:The total Functions in compared is 2038
[Result]:False positive number is 2034
[Result]:False negative number is 2037
[Result]:Precision 0.001963
[Result]:Recall 0.001960
[Result]:F1_Score 0.001961
```

From the result, we observed that the obfuscated `.eh_frame` in the OCFI implementation differ significantly from the symbol information. This divergence highlights the substantial modifications applied to the `.eh_frame`, showcasing the effectiveness of the obfuscation process employed by OCFI.

##### Check the validity of the obfuscated binary(~3mins)

To verify the validity of the obfuscated binary, we conducted separate runs of both the obfuscated and non-obfuscated binaries. By comparing the running results of these two versions, we can effectively assess the consistency and correctness of the obfuscated binary in relation to the original one. This validation process ensures that the obfuscated binary functions as intended and produces reliable results.

- Step 1. For building the non-obfuscated version of qpdf, we utilize commonly used compilers such as gcc or g++. These standard compilers allow us to compile the qpdf source code and generate the non-obfuscated binary. By following this approach, we ensure that the non-obfuscated version is compiled using well-established and widely adopted compilation tools.

```bash
cd $PROJECT_DIR/qpdf-11.0.0
mkdir -p gcc_build && cd gcc_build
# use gcc and g++ to build qpdf
CC=gcc CXX=g++ cmake .. -DCMAKE_INSTALL_PREFIX=$PWD
make -j && make install
```
- Step 2. Run qpdf_ocfi and qpdf_orig seperately and compare the results

To verify the validity of OCFI obfuscation, we executed the `qtest` on both the obfuscated version (`qpdf_ocfi`) and the original version (`qpdf_orig`) of qpdf. By comparing the test results of these two versions and observing that they yield the same outcome, we can conclude that the obfuscation performed by OCFI does not affect the software's validity. This evaluation confirms that the obfuscation process preserves the functionality and reliability of the software while enhancing its security.

```bash
cd $PROJECT_DIR/qpdf-11.0.0
# run qtest on qpdf_ocfi
LD_PRELOAD=$PWD/build/lib/libqpdf.so.29 ./run-qtest --top $PWD --code $PWD/qpdf --bin $PWD/build/bin/ | tee qpdf_obfuscated.log
# run qtest on qpdf_orig
LD_PRELOAD=$PWD/gcc_build/lib/libqpdf.so.29 ./run-qtest --top $PWD --code $PWD/qpdf --bin $PWD/gcc_build/bin/ | tee qpdf_gcc.log
# compare the results
diff qpdf_obfuscated.log qpdf_gcc.log
```

The supposed result is shown as follows:

```
3c3
< STARTING TESTS on Wed May 17 09:15:30 2023
---
> STARTING TESTS on Wed May 17 09:14:09 2023
```
We discovered that the obfuscated binary produces the same outcome as the original one, except for the timestamp associated with the tests.

#### Test Usmith

To test the functionality of Usmith, we use Usmith to generate c++ code with `try` `catch`, compile the source code and run the binary.

```bash
cd $PROJECT_DIR/usmith_build/bin
# generate c++ code with try cath
$PROJECT_DIR/usmith_build/bin/usmith --lang-cpp --cpp11 > $PROJECT_DIR/usmith_build/bin/test.cpp
# compile the source code into binary
g++ $PROJECT_DIR/usmith_build/bin/test.cpp $CFLAGS -O2 -Wno-narrowing -fpermissive -Wwrite-strings -Wno-everything -I$PROJECT_DIR/usmith_build/include -o $PROJECT_DIR/usmith_build/bin/test
# run the binary
$PROJECT_DIR/usmith_build/bin/test
```

The output format is shown as follows:

The output prints the stack depth, function call sequence and the location where the exception is thrown. The `checksum` represents the checksum of the running result.

```plain text
# function call sequence
Enter func_XXX
...
# function that throws an exception 
Now throw from func_XXX !
# the stack depth
Depth is XX
checksum = XXXXX
```

## Detailed Instructions

### Download the Dataset

The dataset contain two parts, our issta dateset and [x86-sok](https://github.com/junxzm1990/x86-sok) dataset.

Overview of the issta dataset:

```
issta_testsuite
├── aarch64_executables # the aarch64 binary for ocfi and orig
│   ├── c_changed
│   ├── cpp_changed
│   ├── cpp_unchanged
│   └── c_unchanged
└── x64_executables # the x64 binary for ocfi and orig
    ├── c_changed
    ├── cpp_changed
    ├── cpp_unchanged
    └── c_unchanged

```

Overview of the x86-sok dataset:

This dataset includes the ground truth of binaries and the disassemblers' results for binaries with eh_frame and binaries without eh_frame. It's important to note that the version of disassemblers used in this dataset are different from those in the x86-sok dataset, so we have provided the results of the disassemblers within the dataset.

```
linux
├── clients
├── cpu2006
├── libs
├── servers
└── utils
```

Command of downloading the datasets:

```bash
bash $PROJECT_DIR/script/dowload_dataset.sh $PROJECT_DIR
```

The supposed result is shown as follows:

```
issta file num: 43682
x86-sok file num: 19709
```

### Steps to reproduce results in Figure 1.(~30mins)

To reproduce the result of Figure 1, we compared the disassemblers' results with symbol information for two binaries: one with `eh_frame`and another without `eh_frame`. By contrasting the disassemblers' output between these two cases, we were able to illustrate the significance of `eh_frame` in enhancing the detection of function entries for binary disassembler, as depicted in Figure 1.

```
bash $PROJECT_DIR/script/run_figure_1.sh -d $PROJECT_DIR/linux -s $PROJECT_DIR
```

### Steps to reproduce results in Figure 6.(~2h)

To reproduce results for Figure 6, we generate 10,000 C++ files and measure the call stack depth for each file. This analysis provides insight into the distribution of call stack depths across a large set of C++ code samples.

```bash
cd $PROJECT_DIR/usmith_build/bin
# copy the collect scripts to usmith directory
cp $PROJECT_DIR/script/usmith/* $PROJECT_DIR/usmith_build/bin
# compile the collection source code
g++ $PROJECT_DIR/usmith_build/bin/count_usmith.cpp -o $PROJECT_DIR/usmith_build/bin/count
# run generate and count script
bash run_usmith.sh $PROJECT_DIR
```

The supposed result is shown as follows(correspond to figure 6):

> The current results obtained from the analysis are preliminary and may exhibit minor variations, but they are highly likely to be consistent with the findings presented in Figure 6.

```
1: 5075
2: 2549
3: 1243
4: 614
5: 268
6: 129
7: 74
8: 33
9: 11
10: 2
11: 3
mean: 1.940406
median: 1.000000
```

### Steps to reproduce Table 2.

To reproduce table 2, we need to build the four projects contained by table 2 : cpu2017, Bloaty, QPDF, Xerces-C.

#### Step 1. build CPU2017

As CPU 2017 is a commical software, we cannot provide source code. Here we provide the configuration files and scripts.

To build the obfuscated and normal binary, you need to copy the configuration files and scirpt to the CPU2017 direactory. (We assume that the CPU2017_DIR represents the path to your CPU2017 installation directory.)

```bash
# copy the configure files and script files to CPU2017 directory
cp $PROJECT_DIR/cpu2017_config/x64/* $CPU2017_DIR/config
cp $PROJECT_DIR/cpu2017_config/aarch64/* $CPU2017_DIR/config
cp $PROJECT_DIR/cpu2017_config/*.sh $CPU2017_DIR
```

- Build for x64_OCFI(~3h)

Build the obfuscated binary of CPU2017 on x64 architecture.

```bash
cd $CPU2017_DIR
bash run_x64_ocfi.sh
```
- Build for aarch64_OCFI(~6h)

Build the obfuscated binary of CPU2017 on aarch64 architecture.

Please note that for this particular task, we utilize qemu to simulate an aarch64 environment. It's important to be aware that the time required for this simulation is generally longer compared to building for the x64 architecture.

```bash
cd $CPU2017_DIR
bash run_aarch64_ocfi.sh
```

#### Step 2. build bloaty(~3mins)

```bash
cd $PROJECT_DIR
git clone https://github.com/google/bloaty.git
cd bloaty
git submodule update --init --recursive
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=$PWD
make -j && make install
```

#### Step 3. build xerces-c(~3mins)

```bash
cd $PROJECT_DIR
git clone https://github.com/apache/xerces-c.git
cd xerces-c
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=$PWD
make -j && make install
```

#### Step 4. build hook_cxa_throw

Here we build a library that hooks into the `cxa_throw` and `cxa_rethrow` functions. This allows us to track and count the number of exceptions thrown when running the binary.

```bash
cd $PROJECT_DIR/hook_cxa_throw
make all
```

#### Step 5. Run cpu2017

Run cpu2017 testsuite for x64 architecture and leverage the `hook_cxa_throw` lib to collect the counts of thrown exceptions and test the validity.

> The results obtained from running the CPU2017 testsuite for both the x64 and aarch64 architectures can be directly correlated with Table 2.

```bash
bash $PROJECT_DIR/cpu2017config/run_x64_ocfi_exception.sh
```

The supposed result is shown as follows:

```
520.omnetpp_r: 5
620.omnetpp_s: 5
541.leela_r: 5
641.leela_s: 5
510.parest_r: 69995
511.povray_r: 10
```

Run cpu2017 testsuite for aarch64 architecture and leverage the `hook_cxa_throw` lib to collect the counts of exceptions and test the validity.

```bash
bash $PROJECT_DIR/cpu2017config/run_aarch64_ocfi_exception.sh
```

The supposed result is shown as follows:

```
520.omnetpp_r: 5
620.omnetpp_s: 5
541.leela_r: 5
641.leela_s: 5
510.parest_r: 69995
511.povray_r: 10
```

#### Step 6. Run bloaty, qpdf and xerces-c

In this phase, we collect the number of exceptions thrown when running three specific software applications: Bloaty, QPDF, and Xerces-C.

```bash
bash $PROJECT_DIR/script/run_table_2.sh -d $PROJECT_DIR/issta_testsuite -s $PROJECT_DIR
```

the number of exceptions collected is shown as follows:

> The result can be directly correlated with Table 2

```
bloaty: 1058
qpdf: 10599
xerces-c: 66
```

### Steps to reproduce results in Figure 7 and Figure 8. (~6h)

To compare the disassemblers' results with symbol information, we analyze both the obfuscated and normal binaries on two different architectures: x64 and aarch64. To depict the results clearly, we show it on figure 7 and figure 8.

> The results are consistent with figure 7 and figure 8.

```bash
bash $PROJECT_DIR/script/run_figure_7_8.sh -d $PROJECT_DIR/issta_testsuite -s $PROJECT_DIR
```

### Steps to reproduce results in Table 4.(~15mins)

In this phase, we compare the size of the obfuscated binary and the normal binary on two different architectures: aarch64 and x64.

> The result can direclty correlated with table 4.

```bash
bash $PROJECT_DIR/script/run_table_4.sh -d $PROJECT_DIR/issta_testsuite -s $PROJECT_DIR
```

### Steps for reproduce the Table 5.

To reproduce the result of Table 5, we need to build CPU2017 with original llvm-12.0.0 on both x64 and aarch64 architecture.

#### Build CPU2017_orig

- build llvm-12.0.0(~30mins)
  
For this part, we build llvm-12.0.0 which has not enable ocfi, so that we could build a original llvm-12.0.0 to compare the ocfi version binary and orig binary.

``` bash
cd $PROJECT_DIR
wget https://github.com/llvm/llvm-project/archive/refs/tags/llvmorg-12.0.0.tar.gz
tar -xvf llvmorg-12.0.0.tar.gz
mkdir -p $PROJECT_DIR/llvm_orig
cd $PROJECT_DIR/llvm_orig
CC=gcc CXX=g++ CFLAGS="" cmake $PROJECT_DIR/llvm-project-llvmorg-12.0.0/llvm -DCMAKE_INSTALL_PREFIX=$PWD -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" 
make -j && make install
```

- Build CPU2017 on x64 with original llvm(~3h)

Build the normal binary of CPU2017 on x64 architecture.

``` bash
cd $CPU2017_DIR
bash run_x64_orig.sh
```

- Build CPU2017 on AArch64 with original llvm(~6h)

Build the normal binary of CPU2017 on AArch64 architecture.

```
cd $CPU2017_DIR
bash run_aarch64_orig.sh
```

#### Compare the time

Run the cpu2017 testsuite for both obfuscated version and non-obfuscated version on x64 architecture and compare the runtime.

```bash
g++ $PROJECT_DIR/script/count_time.cpp -o $PROJECT_DIR/script/time_pre
cd $CPU2017_DIR
bash run_x64_ocfi_time.sh
bash run_x64_orig_time.sh
```

Run the cpu2017 testsuite for both obfuscated version and non-obfuscated version on AArch64 architecture and compare the runtime.

> Due to potential variations in devices and runtime environments, the actual runtimes observed during the execution of the CPU2017 binary may differ from those presented in Table 5. However, it is important to note that the overhead introduced by the OCFI binary remains consistent and is expected to be comparable to the values reported in Table 5.

```bash
g++ $PROJECT_DIR/script/count_time.cpp -o $PROJECT_DIR/script/time_pre
cd $CPU2017_DIR
bash run_aarch64_ocfi_time.sh
bash run_aarch64_orig_time.sh
```

### Steps to reproduce results in Table 6.(~1h)

In this phase, we measure the distributions of function entries identification for the obfuscated binary on two different architectures: aarch64 and x64.

> The result can direclty correlated with table 6.

```bash
bash $PROJECT_DIR/script/run_table_6.sh -d $PROJECT_DIR/issta_testsuite -s $PROJECT_DIR
```